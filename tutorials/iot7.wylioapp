{"tree":[{"name":"Arduino","id":1,"isdir":true,"isroot":true,"children":[{"name":"python","id":2,"isdir":true,"issoftware":true,"children":[{"name":"main.py","id":3,"isdir":false,"ismain":true,"content":"","$$hashKey":"object:679"}],"$$hashKey":"object:672"}]}],"language":"python","notebook":[{"type":"markdown","text":"# Arduino\n\nThe first step is to connect the Arduino to the Raspberry Pi. We will connect it the same way you connect it to a computer using a USB cable. This will make a seriual connection between the Raspberry Pi and the Arduino.\n\n## Flash a firmware\n\nSoftware that is running on microcontrollers is usually called *firmware*. To use the Arduino with the Raspberry Pi, we need to write some firmware that will read sensor data and send it to the Raspberry Pi. This might be defficult. \n\nA simpler solution is to use *Firmata*. This is a firmware that allow you to control the Arduino using the Raspberry Pi with a python library.\n\nFirmata is loaded in the firmware below, press the Flash button.","label":"6e691d57-7f36-4bcd-b438-6d9d05baa576","$$hashKey":"object:398"},{"type":"firmware","text":"/*\n * Firmata is a generic protocol for communicating with microcontrollers\n * from software on a host computer. It is intended to work with\n * any host computer software package.\n *\n * To download a host software package, please clink on the following link\n * to open the download page in your default browser.\n *\n * http://firmata.org/wiki/Download\n */\n\n/*\n  Copyright (C) 2006-2008 Hans-Christoph Steiner.  All rights reserved.\n  Copyright (C) 2010-2011 Paul Stoffregen.  All rights reserved.\n  Copyright (C) 2009 Shigeru Kobayashi.  All rights reserved.\n  Copyright (C) 2009-2011 Jeff Hoefs.  All rights reserved.\n  \n  This library is free software; you can redistribute it and/or\n  modify it under the terms of the GNU Lesser General Public\n  License as published by the Free Software Foundation; either\n  version 2.1 of the License, or (at your option) any later version.\n \n  See file LICENSE.txt for further informations on licensing terms.\n\n  formatted using the GNU C formatting and indenting\n*/\n\n/* \n * TODO: use Program Control to load stored profiles from EEPROM\n */\n\n#include <Servo.h>\n#include <Wire.h>\n#include <Firmata.h>\n\n// move the following defines to Firmata.h?\n#define I2C_WRITE B00000000\n#define I2C_READ B00001000\n#define I2C_READ_CONTINUOUSLY B00010000\n#define I2C_STOP_READING B00011000\n#define I2C_READ_WRITE_MODE_MASK B00011000\n#define I2C_10BIT_ADDRESS_MODE_MASK B00100000\n\n#define MAX_QUERIES 8\n#define MINIMUM_SAMPLING_INTERVAL 10\n\n#define REGISTER_NOT_SPECIFIED -1\n\n/*==============================================================================\n * GLOBAL VARIABLES\n *============================================================================*/\n\n/* analog inputs */\nint analogInputsToReport = 0; // bitwise array to store pin reporting\n\n/* digital input ports */\nbyte reportPINs[TOTAL_PORTS];       // 1 = report this port, 0 = silence\nbyte previousPINs[TOTAL_PORTS];     // previous 8 bits sent\n\n/* pins configuration */\nbyte pinConfig[TOTAL_PINS];         // configuration of every pin\nbyte portConfigInputs[TOTAL_PORTS]; // each bit: 1 = pin in INPUT, 0 = anything else\nint pinState[TOTAL_PINS];           // any value that has been written\n\n/* timer variables */\nunsigned long currentMillis;        // store the current value from millis()\nunsigned long previousMillis;       // for comparison with currentMillis\nint samplingInterval = 19;          // how often to run the main loop (in ms)\n\n/* i2c data */\nstruct i2c_device_info {\n  byte addr;\n  byte reg;\n  byte bytes;\n};\n\n/* for i2c read continuous more */\ni2c_device_info query[MAX_QUERIES];\n\nbyte i2cRxData[32];\nboolean isI2CEnabled = false;\nsigned char queryIndex = -1;\nunsigned int i2cReadDelayTime = 0;  // default delay time between i2c read request and Wire.requestFrom()\n\nServo servos[MAX_SERVOS];\n/*==============================================================================\n * FUNCTIONS\n *============================================================================*/\n\nvoid readAndReportData(byte address, int theRegister, byte numBytes) {\n  // allow I2C requests that don't require a register read\n  // for example, some devices using an interrupt pin to signify new data available\n  // do not always require the register read so upon interrupt you call Wire.requestFrom()  \n  if (theRegister != REGISTER_NOT_SPECIFIED) {\n    Wire.beginTransmission(address);\n    #if ARDUINO >= 100\n    Wire.write((byte)theRegister);\n    #else\n    Wire.send((byte)theRegister);\n    #endif\n    Wire.endTransmission();\n    delayMicroseconds(i2cReadDelayTime);  // delay is necessary for some devices such as WiiNunchuck\n  } else {\n    theRegister = 0;  // fill the register with a dummy value\n  }\n\n  Wire.requestFrom(address, numBytes);  // all bytes are returned in requestFrom\n\n  // check to be sure correct number of bytes were returned by slave\n  if(numBytes == Wire.available()) {\n    i2cRxData[0] = address;\n    i2cRxData[1] = theRegister;\n    for (int i = 0; i < numBytes; i++) {\n      #if ARDUINO >= 100\n      i2cRxData[2 + i] = Wire.read();\n      #else\n      i2cRxData[2 + i] = Wire.receive();\n      #endif\n    }\n  }\n  else {\n    if(numBytes > Wire.available()) {\n      Firmata.sendString(\"I2C Read Error: Too many bytes received\");\n    } else {\n      Firmata.sendString(\"I2C Read Error: Too few bytes received\"); \n    }\n  }\n\n  // send slave address, register and received bytes\n  Firmata.sendSysex(SYSEX_I2C_REPLY, numBytes + 2, i2cRxData);\n}\n\nvoid outputPort(byte portNumber, byte portValue, byte forceSend)\n{\n  // pins not configured as INPUT are cleared to zeros\n  portValue = portValue & portConfigInputs[portNumber];\n  // only send if the value is different than previously sent\n  if(forceSend || previousPINs[portNumber] != portValue) {\n    Firmata.sendDigitalPort(portNumber, portValue);\n    previousPINs[portNumber] = portValue;\n  }\n}\n\n/* -----------------------------------------------------------------------------\n * check all the active digital inputs for change of state, then add any events\n * to the Serial output queue using Serial.print() */\nvoid checkDigitalInputs(void)\n{\n  /* Using non-looping code allows constants to be given to readPort().\n   * The compiler will apply substantial optimizations if the inputs\n   * to readPort() are compile-time constants. */\n  if (TOTAL_PORTS > 0 && reportPINs[0]) outputPort(0, readPort(0, portConfigInputs[0]), false);\n  if (TOTAL_PORTS > 1 && reportPINs[1]) outputPort(1, readPort(1, portConfigInputs[1]), false);\n  if (TOTAL_PORTS > 2 && reportPINs[2]) outputPort(2, readPort(2, portConfigInputs[2]), false);\n  if (TOTAL_PORTS > 3 && reportPINs[3]) outputPort(3, readPort(3, portConfigInputs[3]), false);\n  if (TOTAL_PORTS > 4 && reportPINs[4]) outputPort(4, readPort(4, portConfigInputs[4]), false);\n  if (TOTAL_PORTS > 5 && reportPINs[5]) outputPort(5, readPort(5, portConfigInputs[5]), false);\n  if (TOTAL_PORTS > 6 && reportPINs[6]) outputPort(6, readPort(6, portConfigInputs[6]), false);\n  if (TOTAL_PORTS > 7 && reportPINs[7]) outputPort(7, readPort(7, portConfigInputs[7]), false);\n  if (TOTAL_PORTS > 8 && reportPINs[8]) outputPort(8, readPort(8, portConfigInputs[8]), false);\n  if (TOTAL_PORTS > 9 && reportPINs[9]) outputPort(9, readPort(9, portConfigInputs[9]), false);\n  if (TOTAL_PORTS > 10 && reportPINs[10]) outputPort(10, readPort(10, portConfigInputs[10]), false);\n  if (TOTAL_PORTS > 11 && reportPINs[11]) outputPort(11, readPort(11, portConfigInputs[11]), false);\n  if (TOTAL_PORTS > 12 && reportPINs[12]) outputPort(12, readPort(12, portConfigInputs[12]), false);\n  if (TOTAL_PORTS > 13 && reportPINs[13]) outputPort(13, readPort(13, portConfigInputs[13]), false);\n  if (TOTAL_PORTS > 14 && reportPINs[14]) outputPort(14, readPort(14, portConfigInputs[14]), false);\n  if (TOTAL_PORTS > 15 && reportPINs[15]) outputPort(15, readPort(15, portConfigInputs[15]), false);\n}\n\n// -----------------------------------------------------------------------------\n/* sets the pin mode to the correct state and sets the relevant bits in the\n * two bit-arrays that track Digital I/O and PWM status\n */\nvoid setPinModeCallback(byte pin, int mode)\n{\n  if (pinConfig[pin] == I2C && isI2CEnabled && mode != I2C) {\n    // disable i2c so pins can be used for other functions\n    // the following if statements should reconfigure the pins properly\n    disableI2CPins();\n  }\n  if (IS_PIN_SERVO(pin) && mode != SERVO && servos[PIN_TO_SERVO(pin)].attached()) {\n    servos[PIN_TO_SERVO(pin)].detach();\n  }\n  if (IS_PIN_ANALOG(pin)) {\n    reportAnalogCallback(PIN_TO_ANALOG(pin), mode == ANALOG ? 1 : 0); // turn on/off reporting\n  }\n  if (IS_PIN_DIGITAL(pin)) {\n    if (mode == INPUT) {\n      portConfigInputs[pin/8] |= (1 << (pin & 7));\n    } else {\n      portConfigInputs[pin/8] &= ~(1 << (pin & 7));\n    }\n  }\n  pinState[pin] = 0;\n  switch(mode) {\n  case ANALOG:\n    if (IS_PIN_ANALOG(pin)) {\n      if (IS_PIN_DIGITAL(pin)) {\n        pinMode(PIN_TO_DIGITAL(pin), INPUT); // disable output driver\n        digitalWrite(PIN_TO_DIGITAL(pin), LOW); // disable internal pull-ups\n      }\n      pinConfig[pin] = ANALOG;\n    }\n    break;\n  case INPUT:\n    if (IS_PIN_DIGITAL(pin)) {\n      pinMode(PIN_TO_DIGITAL(pin), INPUT); // disable output driver\n      digitalWrite(PIN_TO_DIGITAL(pin), LOW); // disable internal pull-ups\n      pinConfig[pin] = INPUT;\n    }\n    break;\n  case OUTPUT:\n    if (IS_PIN_DIGITAL(pin)) {\n      digitalWrite(PIN_TO_DIGITAL(pin), LOW); // disable PWM\n      pinMode(PIN_TO_DIGITAL(pin), OUTPUT);\n      pinConfig[pin] = OUTPUT;\n    }\n    break;\n  case PWM:\n    if (IS_PIN_PWM(pin)) {\n      pinMode(PIN_TO_PWM(pin), OUTPUT);\n      analogWrite(PIN_TO_PWM(pin), 0);\n      pinConfig[pin] = PWM;\n    }\n    break;\n  case SERVO:\n    if (IS_PIN_SERVO(pin)) {\n      pinConfig[pin] = SERVO;\n      if (!servos[PIN_TO_SERVO(pin)].attached()) {\n          servos[PIN_TO_SERVO(pin)].attach(PIN_TO_DIGITAL(pin));\n      }\n    }\n    break;\n  case I2C:\n    if (IS_PIN_I2C(pin)) {\n      // mark the pin as i2c\n      // the user must call I2C_CONFIG to enable I2C for a device\n      pinConfig[pin] = I2C;\n    }\n    break;\n  default:\n    Firmata.sendString(\"Unknown pin mode\"); // TODO: put error msgs in EEPROM\n  }\n  // TODO: save status to EEPROM here, if changed\n}\n\nvoid analogWriteCallback(byte pin, int value)\n{\n  if (pin < TOTAL_PINS) {\n    switch(pinConfig[pin]) {\n    case SERVO:\n      if (IS_PIN_SERVO(pin))\n        servos[PIN_TO_SERVO(pin)].write(value);\n        pinState[pin] = value;\n      break;\n    case PWM:\n      if (IS_PIN_PWM(pin))\n        analogWrite(PIN_TO_PWM(pin), value);\n        pinState[pin] = value;\n      break;\n    }\n  }\n}\n\nvoid digitalWriteCallback(byte port, int value)\n{\n  byte pin, lastPin, mask=1, pinWriteMask=0;\n\n  if (port < TOTAL_PORTS) {\n    // create a mask of the pins on this port that are writable.\n    lastPin = port*8+8;\n    if (lastPin > TOTAL_PINS) lastPin = TOTAL_PINS;\n    for (pin=port*8; pin < lastPin; pin++) {\n      // do not disturb non-digital pins (eg, Rx & Tx)\n      if (IS_PIN_DIGITAL(pin)) {\n        // only write to OUTPUT and INPUT (enables pullup)\n        // do not touch pins in PWM, ANALOG, SERVO or other modes\n        if (pinConfig[pin] == OUTPUT || pinConfig[pin] == INPUT) {\n          pinWriteMask |= mask;\n          pinState[pin] = ((byte)value & mask) ? 1 : 0;\n        }\n      }\n      mask = mask << 1;\n    }\n    writePort(port, (byte)value, pinWriteMask);\n  }\n}\n\n\n// -----------------------------------------------------------------------------\n/* sets bits in a bit array (int) to toggle the reporting of the analogIns\n */\n//void FirmataClass::setAnalogPinReporting(byte pin, byte state) {\n//}\nvoid reportAnalogCallback(byte analogPin, int value)\n{\n  if (analogPin < TOTAL_ANALOG_PINS) {\n    if(value == 0) {\n      analogInputsToReport = analogInputsToReport &~ (1 << analogPin);\n    } else {\n      analogInputsToReport = analogInputsToReport | (1 << analogPin);\n    }\n  }\n  // TODO: save status to EEPROM here, if changed\n}\n\nvoid reportDigitalCallback(byte port, int value)\n{\n  if (port < TOTAL_PORTS) {\n    reportPINs[port] = (byte)value;\n  }\n  // do not disable analog reporting on these 8 pins, to allow some\n  // pins used for digital, others analog.  Instead, allow both types\n  // of reporting to be enabled, but check if the pin is configured\n  // as analog when sampling the analog inputs.  Likewise, while\n  // scanning digital pins, portConfigInputs will mask off values from any\n  // pins configured as analog\n}\n\n/*==============================================================================\n * SYSEX-BASED commands\n *============================================================================*/\n\nvoid sysexCallback(byte command, byte argc, byte *argv)\n{\n  byte mode;\n  byte slaveAddress;\n  byte slaveRegister;\n  byte data;\n  unsigned int delayTime; \n  \n  switch(command) {\n  case I2C_REQUEST:\n    mode = argv[1] & I2C_READ_WRITE_MODE_MASK;\n    if (argv[1] & I2C_10BIT_ADDRESS_MODE_MASK) {\n      Firmata.sendString(\"10-bit addressing mode is not yet supported\");\n      return;\n    }\n    else {\n      slaveAddress = argv[0];\n    }\n\n    switch(mode) {\n    case I2C_WRITE:\n      Wire.beginTransmission(slaveAddress);\n      for (byte i = 2; i < argc; i += 2) {\n        data = argv[i] + (argv[i + 1] << 7);\n        #if ARDUINO >= 100\n        Wire.write(data);\n        #else\n        Wire.send(data);\n        #endif\n      }\n      Wire.endTransmission();\n      delayMicroseconds(70);\n      break;\n    case I2C_READ:\n      if (argc == 6) {\n        // a slave register is specified\n        slaveRegister = argv[2] + (argv[3] << 7);\n        data = argv[4] + (argv[5] << 7);  // bytes to read\n        readAndReportData(slaveAddress, (int)slaveRegister, data);\n      }\n      else {\n        // a slave register is NOT specified\n        data = argv[2] + (argv[3] << 7);  // bytes to read\n        readAndReportData(slaveAddress, (int)REGISTER_NOT_SPECIFIED, data);\n      }\n      break;\n    case I2C_READ_CONTINUOUSLY:\n      if ((queryIndex + 1) >= MAX_QUERIES) {\n        // too many queries, just ignore\n        Firmata.sendString(\"too many queries\");\n        break;\n      }\n      queryIndex++;\n      query[queryIndex].addr = slaveAddress;\n      query[queryIndex].reg = argv[2] + (argv[3] << 7);\n      query[queryIndex].bytes = argv[4] + (argv[5] << 7);\n      break;\n    case I2C_STOP_READING:\n    byte queryIndexToSkip;      \n      // if read continuous mode is enabled for only 1 i2c device, disable\n      // read continuous reporting for that device\n      if (queryIndex <= 0) {\n        queryIndex = -1;        \n      } else {\n        // if read continuous mode is enabled for multiple devices,\n        // determine which device to stop reading and remove it's data from\n        // the array, shifiting other array data to fill the space\n        for (byte i = 0; i < queryIndex + 1; i++) {\n          if (query[i].addr = slaveAddress) {\n            queryIndexToSkip = i;\n            break;\n          }\n        }\n        \n        for (byte i = queryIndexToSkip; i<queryIndex + 1; i++) {\n          if (i < MAX_QUERIES) {\n            query[i].addr = query[i+1].addr;\n            query[i].reg = query[i+1].addr;\n            query[i].bytes = query[i+1].bytes; \n          }\n        }\n        queryIndex--;\n      }\n      break;\n    default:\n      break;\n    }\n    break;\n  case I2C_CONFIG:\n    delayTime = (argv[0] + (argv[1] << 7));\n\n    if(delayTime > 0) {\n      i2cReadDelayTime = delayTime;\n    }\n\n    if (!isI2CEnabled) {\n      enableI2CPins();\n    }\n    \n    break;\n  case SERVO_CONFIG:\n    if(argc > 4) {\n      // these vars are here for clarity, they'll optimized away by the compiler\n      byte pin = argv[0];\n      int minPulse = argv[1] + (argv[2] << 7);\n      int maxPulse = argv[3] + (argv[4] << 7);\n\n      if (IS_PIN_SERVO(pin)) {\n        if (servos[PIN_TO_SERVO(pin)].attached())\n          servos[PIN_TO_SERVO(pin)].detach();\n        servos[PIN_TO_SERVO(pin)].attach(PIN_TO_DIGITAL(pin), minPulse, maxPulse);\n        setPinModeCallback(pin, SERVO);\n      }\n    }\n    break;\n  case SAMPLING_INTERVAL:\n    if (argc > 1) {\n      samplingInterval = argv[0] + (argv[1] << 7);\n      if (samplingInterval < MINIMUM_SAMPLING_INTERVAL) {\n        samplingInterval = MINIMUM_SAMPLING_INTERVAL;\n      }      \n    } else {\n      //Firmata.sendString(\"Not enough data\");\n    }\n    break;\n  case EXTENDED_ANALOG:\n    if (argc > 1) {\n      int val = argv[1];\n      if (argc > 2) val |= (argv[2] << 7);\n      if (argc > 3) val |= (argv[3] << 14);\n      analogWriteCallback(argv[0], val);\n    }\n    break;\n  case CAPABILITY_QUERY:\n    Serial.write(START_SYSEX);\n    Serial.write(CAPABILITY_RESPONSE);\n    for (byte pin=0; pin < TOTAL_PINS; pin++) {\n      if (IS_PIN_DIGITAL(pin)) {\n        Serial.write((byte)INPUT);\n        Serial.write(1);\n        Serial.write((byte)OUTPUT);\n        Serial.write(1);\n      }\n      if (IS_PIN_ANALOG(pin)) {\n        Serial.write(ANALOG);\n        Serial.write(10);\n      }\n      if (IS_PIN_PWM(pin)) {\n        Serial.write(PWM);\n        Serial.write(8);\n      }\n      if (IS_PIN_SERVO(pin)) {\n        Serial.write(SERVO);\n        Serial.write(14);\n      }\n      if (IS_PIN_I2C(pin)) {\n        Serial.write(I2C);\n        Serial.write(1);  // to do: determine appropriate value \n      }\n      Serial.write(127);\n    }\n    Serial.write(END_SYSEX);\n    break;\n  case PIN_STATE_QUERY:\n    if (argc > 0) {\n      byte pin=argv[0];\n      Serial.write(START_SYSEX);\n      Serial.write(PIN_STATE_RESPONSE);\n      Serial.write(pin);\n      if (pin < TOTAL_PINS) {\n        Serial.write((byte)pinConfig[pin]);\n  Serial.write((byte)pinState[pin] & 0x7F);\n  if (pinState[pin] & 0xFF80) Serial.write((byte)(pinState[pin] >> 7) & 0x7F);\n  if (pinState[pin] & 0xC000) Serial.write((byte)(pinState[pin] >> 14) & 0x7F);\n      }\n      Serial.write(END_SYSEX);\n    }\n    break;\n  case ANALOG_MAPPING_QUERY:\n    Serial.write(START_SYSEX);\n    Serial.write(ANALOG_MAPPING_RESPONSE);\n    for (byte pin=0; pin < TOTAL_PINS; pin++) {\n      Serial.write(IS_PIN_ANALOG(pin) ? PIN_TO_ANALOG(pin) : 127);\n    }\n    Serial.write(END_SYSEX);\n    break;\n  }\n}\n\nvoid enableI2CPins()\n{\n  byte i;\n  // is there a faster way to do this? would probaby require importing \n  // Arduino.h to get SCL and SDA pins\n  for (i=0; i < TOTAL_PINS; i++) {\n    if(IS_PIN_I2C(i)) {\n      // mark pins as i2c so they are ignore in non i2c data requests\n      setPinModeCallback(i, I2C);\n    } \n  }\n   \n  isI2CEnabled = true; \n  \n  // is there enough time before the first I2C request to call this here?\n  Wire.begin();\n}\n\n/* disable the i2c pins so they can be used for other functions */\nvoid disableI2CPins() {\n    isI2CEnabled = false;\n    // disable read continuous mode for all devices\n    queryIndex = -1;\n    // uncomment the following if or when the end() method is added to Wire library\n    // Wire.end();\n}\n\n/*==============================================================================\n * SETUP()\n *============================================================================*/\n\nvoid systemResetCallback()\n{\n  // initialize a defalt state\n  // TODO: option to load config from EEPROM instead of default\n  if (isI2CEnabled) {\n    disableI2CPins();\n  }\n  for (byte i=0; i < TOTAL_PORTS; i++) {\n    reportPINs[i] = false;      // by default, reporting off\n    portConfigInputs[i] = 0;  // until activated\n    previousPINs[i] = 0;\n  }\n  // pins with analog capability default to analog input\n  // otherwise, pins default to digital output\n  for (byte i=0; i < TOTAL_PINS; i++) {\n    if (IS_PIN_ANALOG(i)) {\n      // turns off pullup, configures everything\n      setPinModeCallback(i, ANALOG);\n    } else {\n      // sets the output to 0, configures portConfigInputs\n      setPinModeCallback(i, OUTPUT);\n    }\n  }\n  // by default, do not report any analog inputs\n  analogInputsToReport = 0;\n\n  /* send digital inputs to set the initial state on the host computer,\n   * since once in the loop(), this firmware will only send on change */\n  /*\n  TODO: this can never execute, since no pins default to digital input\n        but it will be needed when/if we support EEPROM stored config\n  for (byte i=0; i < TOTAL_PORTS; i++) {\n    outputPort(i, readPort(i, portConfigInputs[i]), true);\n  }\n  */\n}\n\nvoid setup() \n{\n  Firmata.setFirmwareVersion(FIRMATA_MAJOR_VERSION, FIRMATA_MINOR_VERSION);\n\n  Firmata.attach(ANALOG_MESSAGE, analogWriteCallback);\n  Firmata.attach(DIGITAL_MESSAGE, digitalWriteCallback);\n  Firmata.attach(REPORT_ANALOG, reportAnalogCallback);\n  Firmata.attach(REPORT_DIGITAL, reportDigitalCallback);\n  Firmata.attach(SET_PIN_MODE, setPinModeCallback);\n  Firmata.attach(START_SYSEX, sysexCallback);\n  Firmata.attach(SYSTEM_RESET, systemResetCallback);\n\n  Firmata.begin(57600);\n  systemResetCallback();  // reset to default config\n}\n\n/*==============================================================================\n * LOOP()\n *============================================================================*/\nvoid loop() \n{\n  byte pin, analogPin;\n\n  /* DIGITALREAD - as fast as possible, check for changes and output them to the\n   * FTDI buffer using Serial.print()  */\n  checkDigitalInputs();  \n\n  /* SERIALREAD - processing incoming messagse as soon as possible, while still\n   * checking digital inputs.  */\n  while(Firmata.available())\n    Firmata.processInput();\n\n  /* SEND FTDI WRITE BUFFER - make sure that the FTDI buffer doesn't go over\n   * 60 bytes. use a timer to sending an event character every 4 ms to\n   * trigger the buffer to dump. */\n\n  currentMillis = millis();\n  if (currentMillis - previousMillis > samplingInterval) {\n    previousMillis += samplingInterval;\n    /* ANALOGREAD - do all analogReads() at the configured sampling interval */\n    for(pin=0; pin<TOTAL_PINS; pin++) {\n      if (IS_PIN_ANALOG(pin) && pinConfig[pin] == ANALOG) {\n        analogPin = PIN_TO_ANALOG(pin);\n        if (analogInputsToReport & (1 << analogPin)) {\n          Firmata.sendAnalog(analogPin, analogRead(analogPin));\n        }\n      }\n    }\n    // report i2c data for all device with read continuous mode enabled\n    if (queryIndex > -1) {\n      for (byte i = 0; i < queryIndex + 1; i++) {\n        readAndReportData(query[i].addr, query[i].reg, query[i].bytes);\n      }\n    }\n  }\n}\n","label":"9f0f3285-bda3-45b9-ae45-e39d11fcd1fa","port":{"type":"arduino/uno","path":"/dev/ttyACM0"},"$$hashKey":"object:735","response":"","hasErrors":true,"stdout":"","stderr":""},{"type":"markdown","text":"# PyMata\n\nThe python library that talk to firmata is *pymata*. To install it, got to the Shell and run\n\n    sudo pip install pymata\n\nLet's import it","label":"5cc4b62f-4046-4329-86af-d39305028985","port":{"type":"arduino/uno"},"$$hashKey":"object:1144"},{"type":"code","text":"from PyMata.pymata import PyMata # import pymata\n\narduino = PyMata(\"/dev/ttyACM0\") # connect to an arduino\n\n","label":"8347a274-6df4-41e2-9e35-cc735e0b679d","port":{"type":""},"$$hashKey":"object:1399","exception":"","stdout":"","stderr":""},{"type":"markdown","text":"## Blink a LED\n\n Let's blink a led on the Arduino","label":"2d251fc4-8803-403c-83e5-f7fb3db1a8b0","port":{"type":""},"$$hashKey":"object:1571"},{"type":"code","text":"import time\narduino.set_pin_mode (13, arduino.OUTPUT, arduino.DIGITAL)\n\nwhile True:\n  arduino.digital_write (13, arduino.HIGH)\n  time.sleep (1)\n  arduino.digital_write (13, arduino.LOW)\n  time.sleep (1)\n  ","label":"36d168a7-4ca4-455a-ac1b-ddf39ada8a04","port":{"type":""},"$$hashKey":"object:1819","exception":"","stdout":"","stderr":""},{"type":"markdown","text":"## Reading an analog sensor\n\nThe simple sensors are analog, so reading them actually means reading a voltage value. The ADC on the Arduino is connected to pins A0 to A6. The value return is from 0 to 1023.\n\nTo read an analog value, we will use the function *analog_read*().\n\nLet's connect a light sensor on pin A0 and run the code.","label":"a2403110-5a5d-4ccb-93aa-e3a697e432fc","port":{"type":""},"$$hashKey":"object:2023"},{"type":"code","text":"arduino.set_pin_mode (0, arduino.INPUT, arduino.ANALOG)\n\nwhile True:\n  print arduino.analog_read (0)\n  time.sleep (1)\n  ","label":"e9f5d825-5308-444a-90ef-0fb3e7f97f9b","port":{"type":""},"$$hashKey":"object:2200","exception":"","stdout":"1\n","stderr":""}],"title":"Arduino","date":1485875157293}